<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <title>BitKözpont – Univerzális feladatmegoldó (1–20)</title>
    <style>
        body { font-family: Arial, sans-serif; background:#222; color:#eee; padding:20px; }
        label { display:inline-block; margin-bottom:6px; }
        input[type="number"], input[type="text"] { padding:4px 6px; margin-right:8px; }
        button { padding:6px 12px; margin:4px 4px 4px 0; cursor:pointer; }
        pre {
            background:#111;
            color:#0f0;
            padding:10px;
            border-radius:6px;
            font-size:0.8rem;
            overflow-x:auto;
            max-height:300px;
        }
        .panel {
            background:#181818;
            padding:10px;
            border-radius:8px;
            margin-top:10px;
            box-shadow:0 0 4px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>

<h1>BitKözpont – Univerzális feladatmegoldó (1–20)</h1>

<div>
    <label>Teamcode:
        <input type="text" id="teamcode" value="a844b7d39462bf1f46d6" size="30">
    </label>
</div>

<div style="margin-top:8px;">
    <label>Feladat ID (1–20):
        <input type="number" id="taskIdInput" min="1" max="20" value="7">
    </label>
    <button onclick="loadTask()">Feladat lekérése</button>
    <button onclick="generateAnswers()">Megoldás generálása</button>
    <button onclick="submitAnswers()">Megoldás beküldése</button>
</div>

<div class="panel">
    <strong>Kapott feladat (gettasks.php → data):</strong>
    <pre id="taskDataPre">Nincs adat</pre>
</div>

<div class="panel">
    <strong>Generált answer_data (id + answer per kérdés):</strong>
    <pre id="answersPre">Nincs adat</pre>
</div>

<div class="panel">
    <strong>Beküldött JSON (answer.php):</strong>
    <pre id="requestPre">Nincs adat</pre>
</div>

<div class="panel">
    <strong>Szerver válasza (answer.php):</strong>
    <pre id="responsePre">Nincs adat</pre>
</div>

<script>
// ========= Globális állapot =========
let originalEnvelope = null;  // teljes gettasks válasz
let originalData = null;      // data
let originalHash = null;      // hash
let generatedAnswers = null;  // answer_data (tömb: {id, answer})

// ========= Feladat lekérése =========
async function loadTask() {
    const teamcode = document.getElementById("teamcode").value.trim();
    const taskId = parseInt(document.getElementById("taskIdInput").value, 10);

    originalEnvelope = null;
    originalData = null;
    originalHash = null;
    generatedAnswers = null;

    document.getElementById("taskDataPre").textContent = "Lekérés folyamatban...";
    document.getElementById("answersPre").textContent = "Nincs adat";
    document.getElementById("requestPre").textContent = "Nincs adat";
    document.getElementById("responsePre").textContent = "Nincs adat";

    try {
        const res = await fetch("https://bitkozpont.mik.uni-pannon.hu/2025/gettasks.php", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                id: taskId,
                teamcode: teamcode
            })
        });

        const json = await res.json();
        originalEnvelope = json;

        if (json.status !== "success") {
            document.getElementById("taskDataPre").textContent =
                "Hiba a feladat lekérésekor:\n" + JSON.stringify(json, null, 2);
            return;
        }

        originalData = json.data;
        originalHash = json.hash;

        document.getElementById("taskDataPre").textContent =
            JSON.stringify(json.data, null, 2);

    } catch (err) {
        document.getElementById("taskDataPre").textContent =
            "Fetch hiba: " + err;
    }
}

// ========= Segédfüggvények =========

// Távolságmátrix (2. feladat logika)
function distanceMatrix(positions) {
    const n = positions.length;
    const mat = Array.from({length:n}, () => Array(n).fill(0));
    for (let i=0;i<n;i++) {
        for (let j=0;j<n;j++) {
            if (i === j) continue;
            const dx = positions[i].x - positions[j].x;
            const dy = positions[i].y - positions[j].y;
            const d = Math.sqrt(dx*dx + dy*dy);
            mat[i][j] = Math.ceil(d);
        }
    }
    return mat;
}

// ========= AI egy kérdésre (típusfüggő) =========
function solveQuestion(q) {
    const params = q.params;
    const type = params.type;

    if (type === "DISTMATRIX") {
        // 2. feladat
        const mat = distanceMatrix(params.positions);
        return mat;
    }

    if (type === "BASICMINING") {
        // 3. feladat: minden aszteroida kibányászása
        const positions = params.positions;
        const shipCount = params.shipCount;
        const baseIndex = positions.findIndex(p => p.type === "Base");
        const asteroids = positions
            .map((p,idx) => ({...p, idx}))
            .filter(p => p.type === "Asteroid");

        const commandsPerShip = [];
        for (let s=0; s<shipCount; s++) {
            const cmds = [];
            cmds.push({ command:"STARTFROM", position: baseIndex });
            for (const a of asteroids) {
                cmds.push({ command:"MOVE", position:a.idx });
                cmds.push({ command:"MINE", rounds:50 });
                cmds.push({ command:"MOVE", position:baseIndex });
            }
            commandsPerShip.push(cmds);
        }

        return {
            commands: commandsPerShip,
            totalRounds: 0,
            totalMined: 0
        };
    }

    if (type === "BASICUPGRADE") {
        // 4. feladat: max upgrade + bányászat
        const positions = params.positions;
        const baseIndex = positions.findIndex(p => p.type === "Base");
        const astIndex = positions.findIndex(p => p.type === "Asteroid");
        const shipCount = params.shipCount;

        const commandsPerShip = [];
        const cmds = [];
        cmds.push({ command:"STARTFROM", position: baseIndex });

        // először sok bányászat, hogy legyen érc
        for (let i=0; i<20; i++) {
            cmds.push({ command:"MOVE", position: astIndex });
            cmds.push({ command:"MINE", rounds: 20 });
            cmds.push({ command:"MOVE", position: baseIndex });
        }

        // upgrade-ek maxra
        for (let i=0;i<5;i++) cmds.push({ command:"UPGRADE", attribute:"mining_speed" });
        for (let i=0;i<5;i++) cmds.push({ command:"UPGRADE", attribute:"move_speed" });
        for (let i=0;i<5;i++) cmds.push({ command:"UPGRADE", attribute:"capacity" });

        // még bányászat
        cmds.push({ command:"MOVE", position: astIndex });
        cmds.push({ command:"MINE", rounds: 50 });
        cmds.push({ command:"MOVE", position: baseIndex });

        commandsPerShip.push(cmds);

        for (let s=1; s<shipCount; s++) {
            commandsPerShip.push([
                { command:"STARTFROM", position: baseIndex }
            ]);
        }

        return {
            commands: commandsPerShip,
            totalRounds: 0,
            totalMined: 0,
            stockQuantity: 0
        };
    }

    if (type === "SOLVEMAP") {
        // 6. + 7–20. feladatok – pontszerzés (fejleszt + új hajók vásárlása)
        return solveSolvemap(params);
    }

    // Ismeretlen típus esetén:
    return {};
}

// ========= SOLVEMAP AI – több hajó, folyamatos upgrade, új hajók vásárlása =========
function solveSolvemap(params) {
    const positions = params.positions;
    const shipCountInitial = params.shipCount;
    const roundLimit = params.roundLimit;

    const distMat = distanceMatrix(positions);

    // hajó alap statok
    const BASE_MOVE = 10;
    const BASE_CAP = 25;
    const BASE_MINE = 15;

    const COST_MOVE = 70, STEP_MOVE = 4;
    const COST_CAP  = 100, STEP_CAP  = 15;
    const COST_MINE = 35, STEP_MINE = 8;
    const MAX_UP = 5;

    // összes bázis
    const baseIndexes = positions
        .map((p,i)=>p.type==="Base" ? i : -1)
        .filter(i=>i!==-1);

    if (baseIndexes.length === 0) {
        const cmdsEmpty = Array.from({length:shipCountInitial}, ()=>[]);
        return { commands: cmdsEmpty, newShips: [] };
    }

    // aszteroidák + maradék mennyiség
    const asteroids = positions
        .map((p,i)=>p.type==="Asteroid" ? {idx:i, quantity:p.quantity} : null)
        .filter(x=>x);

    const remaining = {};
    for (const a of asteroids) remaining[a.idx] = a.quantity;

    // aszteroidák hozzárendelése legközelebbi bázishoz
    const assignedBase = {};
    for (const a of asteroids) {
        let bestB = baseIndexes[0];
        let bestD = distMat[a.idx][bestB];
        for (const b of baseIndexes) {
            const d = distMat[a.idx][b];
            if (d < bestD) { bestD = d; bestB = b; }
        }
        assignedBase[a.idx] = bestB;
    }

    // hajók + parancsok
    const ships = [];
    const commandsPerShip = [];

    for (let s=0; s<shipCountInitial; s++) {
        const base = baseIndexes[s % baseIndexes.length];
        const ship = {
            pos: base,
            baseIndex: base,
            move: BASE_MOVE,
            cap: BASE_CAP,
            mine: BASE_MINE,
            cargo: 0,
            t: 0,
            up: { move:0, cap:0, mine:0 },
            active: true
        };
        ships.push(ship);
        const cmds = [];
        cmds.push({ command:"STARTFROM", position: base });
        commandsPerShip.push(cmds);
    }

    const stock = { value: 0 };
    const newShipsTurns = []; // ide gyűjtjük a vásárlások köreit (round)

    const SAFE_LIMIT = Math.floor(roundLimit * 0.95);

    // Folyamatos upgrade logika (mining → move → capacity)
    function tryAutoUpgrades(ship, cmds, stock) {
        let changed = true;
        while (changed) {
            changed = false;

            // 1) mining_speed
            if (ship.up.mine < MAX_UP && stock.value >= COST_MINE) {
                cmds.push({ command:"UPGRADE", attribute:"mining_speed" });
                stock.value -= COST_MINE;
                ship.mine += STEP_MINE;
                ship.up.mine++;
                ship.t++; // 1 kör upgrade
                changed = true;
                continue;
            }

            // 2) move_speed
            if (ship.up.move < MAX_UP && stock.value >= COST_MOVE) {
                cmds.push({ command:"UPGRADE", attribute:"move_speed" });
                stock.value -= COST_MOVE;
                ship.move += STEP_MOVE;
                ship.up.move++;
                ship.t++;
                changed = true;
                continue;
            }

            // 3) capacity
            if (ship.up.cap < MAX_UP && stock.value >= COST_CAP) {
                cmds.push({ command:"UPGRADE", attribute:"capacity" });
                stock.value -= COST_CAP;
                ship.cap += STEP_CAP;
                ship.up.cap++;
                ship.t++;
                changed = true;
                continue;
            }
        }
    }

    // Új hajók vásárlása – mindig 300 érc / hajó
    function tryBuyNewShips(stock, newShipsTurns, currentRound, ships, commandsPerShip) {
        // minél korábban, annál jobb → ha megvan a 300, veszünk
        while (stock.value >= 300) {
            stock.value -= 300;
            newShipsTurns.push(currentRound);

            const newIndex = ships.length;
            const base = baseIndexes[newIndex % baseIndexes.length];

            const newShip = {
                pos: base,
                baseIndex: base,
                move: BASE_MOVE,
                cap: BASE_CAP,
                mine: BASE_MINE,
                cargo: 0,
                t: currentRound + 1, // 1 kör építés után indul
                up: { move:0, cap:0, mine:0 },
                active: true
            };
            ships.push(newShip);

            const cmds = [];
            cmds.push({ command:"STARTFROM", position: base });
            commandsPerShip.push(cmds);
        }
    }

    // Egy aszteroida választása adott hajónak (a saját bázisához rendelt aszteroidák közül)
    function bestAstForShip(ship) {
        let bestIdx = null;
        let bestScore = 0;
        for (const a of asteroids) {
            const idx = a.idx;
            if (remaining[idx] <= 0) continue;
            if (assignedBase[idx] !== ship.baseIndex) continue;
            const d = distMat[ship.baseIndex][idx] || 1;
            const score = remaining[idx] / d;
            if (score > bestScore) {
                bestScore = score;
                bestIdx = idx;
            }
        }
        return bestIdx;
    }

    // Trip: base -> asteroid -> mine -> base -> deposit
    function simulateTrip(ship, astIndex, cmds) {
        const base = ship.baseIndex;

        // base/aktuális -> asteroid
        if (ship.pos !== astIndex) {
            const d1 = distMat[ship.pos][astIndex];
            const r1 = Math.ceil(d1 / ship.move);
            ship.t += r1;
            cmds.push({ command:"MOVE", position: astIndex });
            ship.pos = astIndex;
        }

        // MINE
        let free = ship.cap - ship.cargo;
        let avail = remaining[astIndex];
        if (free > 0 && avail > 0) {
            const target = Math.min(free, avail);
            const mineRounds = Math.ceil(target / ship.mine);
            ship.t += mineRounds;
            cmds.push({ command:"MINE", rounds: mineRounds });

            const mined = Math.min(avail, mineRounds * ship.mine, free);
            ship.cargo += mined;
            remaining[astIndex] -= mined;
        }

        // asteroid -> base
        if (ship.pos !== base) {
            const d2 = distMat[ship.pos][base];
            const r2 = Math.ceil(d2 / ship.move);
            ship.t += r2;
            cmds.push({ command:"MOVE", position: base });
            ship.pos = base;
        }

        // deposit
        stock.value += ship.cargo;
        ship.cargo = 0;
    }

    // Fő bányász ciklus – mindig a legkevesebb "t" idejű aktív hajó lép
    while (true) {
        // legkevesebb t-vel rendelkező aktív hajó kiválasztása
        let bestShipIndex = -1;
        let bestT = Infinity;
        for (let i=0; i<ships.length; i++) {
            const sh = ships[i];
            if (!sh.active) continue;
            if (sh.t < bestT) {
                bestT = sh.t;
                bestShipIndex = i;
            }
        }

        if (bestShipIndex === -1) break; // nincs aktív hajó
        const ship = ships[bestShipIndex];
        const cmds = commandsPerShip[bestShipIndex];

        if (ship.t >= SAFE_LIMIT) {
            ship.active = false;
            continue;
        }

        const aIdx = bestAstForShip(ship);
        if (aIdx === null) {
            // nincs már értelmes aszteroida ennek a bázisnak
            ship.active = false;
            continue;
        }

        simulateTrip(ship, aIdx, cmds);

        // folyamatos upgrade
        tryAutoUpgrades(ship, cmds, stock);

        // új hajó vásárlási próbálkozás (a jelenlegi "round" közelítően ship.t)
        const currentRound = Math.floor(ship.t);
        if (currentRound < SAFE_LIMIT * 0.7) { // csak a játék első ~70%-ában veszünk új hajót
            tryBuyNewShips(stock, newShipsTurns, currentRound, ships, commandsPerShip);
        }

        if (ship.t >= SAFE_LIMIT) {
            ship.active = false;
        }
    }

    return {
        commands: commandsPerShip,
        newShips: newShipsTurns
    };
}

// ========= Megoldás generálása az aktuális feladatra =========
function generateAnswers() {
    if (!originalData) {
        alert("Előbb kérd le a feladatot!");
        return;
    }

    const questions = originalData.questions || [];
    const answers = questions.map(q => {
        const solved = solveQuestion(q);
        return {
            id: q.ID,   // kérdés ID-je
            answer: solved
        };
    });

    generatedAnswers = answers;

    document.getElementById("answersPre").textContent =
        JSON.stringify(answers, null, 2);
}

// ========= Megoldás beküldése =========
async function submitAnswers() {
    if (!originalData || !originalHash) {
        alert("Nincs lekért feladat!");
        return;
    }
    if (!generatedAnswers) {
        alert("Nincs generált megoldás!");
        return;
    }

    const teamcode = document.getElementById("teamcode").value.trim();

    const payload = {
        id: originalData.ID,          // fontos: a feladat ID-je (pl. 7)
        teamcode: teamcode,
        original_data: originalData,  // teljes data
        original_hash: originalHash,  // gettasks hash
        answer_data: generatedAnswers // [{ id: questionID, answer: {...} }]
    };

    document.getElementById("requestPre").textContent =
        JSON.stringify(payload, null, 2);

    try {
        const res = await fetch("https://bitkozpont.mik.uni-pannon.hu/2025/answer.php", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
        });

        const json = await res.json();
        document.getElementById("responsePre").textContent =
            JSON.stringify(json, null, 2);

    } catch (err) {
        document.getElementById("responsePre").textContent =
            "Fetch hiba: " + err;
    }
}
</script>

</body>
</html>
